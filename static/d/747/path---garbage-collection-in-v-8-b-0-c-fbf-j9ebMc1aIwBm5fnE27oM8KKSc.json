{"data":{"site":{"siteMetadata":{"title":"Kaier33","author":"KaierChou"}},"markdownRemark":{"id":"a3b7b68a-ebb7-562a-bd9e-87e53c4f4a68","html":"<p>，。；：？！ <br/>\n许多现代语言引擎，如Chrome的V8 JavaScript引擎，都能动态地管理运行中的应用程序的内存，因此开发人员不需要自己担心。引擎会定期翻阅分配给应用程序的内存，确定哪些数据不再需要，并将其清除以腾出空间，这个过程被称为垃圾收集。</p>\n<p>任何垃圾收集器(GC)都有一些基本的任务, 它必须定期进行。</p>\n<ol>\n<li>识别objects的状态(live/dead)</li>\n<li>回收/再利用dead object所占用的内存</li>\n<li>优化整理内存</li>\n</ol>\n<p>这些任务可以按顺序执行，也可以任意交错执行。一种直接的方法是暂停JavaScript执行，并在主线程上依次执行这些任务。这可能会导致主线程上的卡顿和延迟问题，同时也会降低程序的吞吐量。</p>\n<h2 id=\"major-gc-full-mark-compact\"><a href=\"#major-gc-full-mark-compact\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Major GC (Full Mark-Compact)</h2>\n<p>主GC分为三个阶段：标记，清除和压缩。</p>\n<div align=\"center\">\n  <img src=\"https://i.ibb.co/5r4yyd2/gc-02.png\">\n</div>\n<h2 id=\"generational-layout\"><a href=\"#generational-layout\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Generational layout</h2>\n<p>V8中的堆被划分为不同的区域：<br/>\n有young generation(新生代)和old generation(老生代)。<br/>\n新生代内部进一步划分为“nursery幼生代”和“intermediate中间代”2个子代。<br/></p>\n<p>对象首先分配到nursery(幼生代)，如果它们能在下一次GC中存活下来，则会被移动到intermediate(中间代)，如果它们在再次从GC中存活下来，就会被移到old generation(老生代)中去。</p>\n<div align=\"center\">\n  <img src=\"https://i.ibb.co/gW87MnK/gc-01.png\">\n</div>\n<h2 id=\"minor-gc-scavenger\"><a href=\"#minor-gc-scavenger\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Minor GC (Scavenger)</h2>\n<p>V8中有两个垃圾收集器：<br/>\n主GC<a href=\"#major-gc-full-mark-compact\">Major GC(Mark-Compact)</a>从整个堆中收集垃圾；<br/>\n次GC<a href=\"#minor-gc-scavenger\">Minor GC (Scavenger)</a>在young generation(新生代)中收集垃圾。<br/></p>\n<p>\n在只在新生代内收集的Scavenger中，幸存的对象总是被evacuation（这个不好翻译啊喂, 暂且称为复制迁移）到新的内存页中。V8对young generation(新生代)采用了semi-space(半空间)设计。这意味着总空间的一半始终是空的，以便进行这个evacuation步骤。在清理过程中，这个初始为空的区域被称为'To-Space'。我们从这里复制的区域叫做 \"From-Space\"。在最坏的情况下，每个对象都可以在清扫中存活下来，我们需要复制每个对象。\n<p>\n<p>\n对于清理，我们会维护一个额外的根集（root set），这个根集里会存放一些从旧到新的引用。这些引用是在旧空间（old-space）中指向新生代中对象的指针。我们使用“写屏障（write barriers）”来维护从旧到新的引用列表，而不是跟踪整个堆中的每一个对象变更。当堆和全局对象结合使用时，我们知道每一个在新生代中对象的引用，而无需追踪整个老生代。\n</p>\n<p>\nevacuation步骤将所有存活的对象移动到一个连续的内存块中（在一个内存页内）。这样做的好处是完成去除碎片化--死对象留下的空隙。然后，我们将两个空间进行切换，即To-Space变成From-Space，反之亦然。GC完成后，新的分配发生在From-Space的下一个空闲地址。\n<p>\n<div align=\"center\">\n  <img style=\"margin-bottom: 0px\" src=\"https://i.ibb.co/NF5X8pK/gc-03.png\">\n  <span style=\"color: #666; font-size: 14px\">&#x6B21;GC&#x79FB;&#x52A8;&#x6D3B;&#x52A8;&#x5BF9;&#x8C61;&#x5230;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x5185;&#x5B58;&#x9875;</span>\n</div>\n<p>仅凭这一策略，我们很快就会在young generation(新生代)中耗尽空间。在第二个GC中幸存下来的对象被evacuation(复制迁移)到old generation(老生代)中，而不是'To-Space'。</p>\n<p>清除的最后一步是更新引用已移动的原始对象的指针。每个复制的对象都会留下一个转发地址，用于将原始指针更新为指向新位置。</p>\n<div align=\"center\">\n  <img style=\"margin-bottom: 0px\" src=\"https://i.ibb.co/QvyrPXB/gc-04.png\">\n  <span style=\"color: #666; font-size: 14px\">&#x6B21;GC&#x5C06;&#x6D3B;&#x8DC3;&#x5BF9;&#x8C61;&#x79FB;&#x52A8;&#x5230;&#x8001;&#x751F;&#x4EE3;</span>\n</div>\n<p>次GC在清理时，实际上执行三个步骤：标记，移动活动对象，和更新对象的指针；这三个步骤是交错进行的，而不是分阶段进行的。</p>\n<h2 id=\"orinoco\"><a href=\"#orinoco\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Orinoco</h2>\n<p>衡量垃圾收集所花时间的一个重要指标是GC执行时主线程暂停的时间。对于传统的 “stop-the-world”(全暂停)垃圾收集器来说，这个时间真的会增加，而且这些做GC的时间会直接影响到用户体验，表现为页面的卡顿和糟糕的渲染和延迟。</p>\n<div align=\"center\">\n  <img style=\"margin-bottom: 0px; width: 200px; display: block\" src=\"https://v8.dev/_img/v8-orinoco.svg\">\n  <span style=\"color: #666; font-size: 14px\">Orinoco&#x7684;Logo</span>\n</div>\n<p>Orinoco是GC项目的代号，利用最新最先进的并行、增量和并发技术进行垃圾收集，以解放主线程。下面是一些术语在GC上下文中的详细定义。</p>\n<h3 id=\"并行式垃圾回收（parallel）\"><a href=\"#%E5%B9%B6%E8%A1%8C%E5%BC%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88parallel%EF%BC%89\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>并行式垃圾回收（Parallel）</h3>\n<p>并行式垃圾回收是指主线程和辅助线程在同一时间做大致相等的工作。这仍然是一种”stop-the-world”(全暂停)的方法，但总的暂停时间现在被参与的线程数量除以（加上同步的一些开销）。这是三种技术中最简单的一种。JavaScript堆是暂停的，因为没有JavaScript运行，所以每个辅助线程只需要确保它同步访问另一个辅助线程可能也想访问的任何对象。</p>\n<div align=\"center\">\n  <img style=\"margin-bottom: 0px;display: block\" src=\"https://v8.dev/_img/trash-talk/05.svg\">\n  <span style=\"color: #666; font-size: 14px\">&#x4E3B;&#x7EBF;&#x7A0B;&#x548C;&#x8F85;&#x52A9;&#x7EBF;&#x7A0B;&#x540C;&#x65F6;&#x8FDB;&#x884C;GC&#x5904;&#x7406;&#x3002;</span>\n</div>\n<h3 id=\"增量式垃圾回收（incremental）\"><a href=\"#%E5%A2%9E%E9%87%8F%E5%BC%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88incremental%EF%BC%89\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>增量式垃圾回收（Incremental）</h3>\n<p>增量式垃圾回收是指主线断断续续地做一小段工作。我们在增量暂停中并不是做整个GC，只是做GC所需的总工作中的一小段。这一点比较困难，因为JavaScript在每个增量工作段之间都会执行，这意味着堆的状态发生了变化，可能会使之前增量完成的工作失效。从图中可以看出，这并没有减少花在主线程上的时间（事实上，通常会略微增加），只是把时间分散了。对于解决我们最初的一个问题：主线程延迟，这还是一个不错的技术。通过让JavaScript间歇性运行，但也继续垃圾收集任务，用户在输入或者执行动画的时候仍能得到及时的响应。</p>\n<div align=\"center\">\n  <img style=\"margin-bottom: 0px;display: block\" src=\"https://v8.dev/_img/trash-talk/06.svg\">\n  <span style=\"color: #666; font-size: 14px\">&#x5C0F;&#x5757;&#x7684;GC&#x4EFB;&#x52A1;&#x7A7F;&#x63D2;&#x5728;&#x4E3B;&#x7EBF;&#x7A0B;&#x7684;&#x6267;&#x884C;&#x4E2D;&#x3002;</span>\n</div>\n<h3 id=\"并发式垃圾回收（concurrent）\"><a href=\"#%E5%B9%B6%E5%8F%91%E5%BC%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88concurrent%EF%BC%89\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>并发式垃圾回收（Concurrent）</h3>\n<p>并发式垃圾回收是指主线程不断地执行JavaScript，而辅助线程完全在后台做GC工作。这是三种技术中最困难的一种：JavaScript堆上的任何东西都可能随时发生变化，使我们之前所做的工作失效。除此之外，现在还要担心读/写竞争，因为辅助线程和主线程同时读取或修改同一个对象。这里的好处是，主线程完全可以自由地执行JavaScript—虽然由于与辅助线程的一些同步，会有一些小的开销。</p>\n<div align=\"center\">\n  <img style=\"margin-bottom: 0px;display: block\" src=\"https://v8.dev/_img/trash-talk/07.svg\">\n  <span style=\"color: #666; font-size: 14px\">GC&#x4EFB;&#x52A1;&#x5B8C;&#x5168;&#x53D1;&#x751F;&#x5728;&#x540E;&#x53F0;&#x3002;&#x4E3B;&#x7EBF;&#x7A0B;&#x53EF;&#x4EE5;&#x81EA;&#x7531;&#x8FD0;&#x884C;JavaScript&#x3002;</span>\n</div>\nhttps://v8.dev/_img/trash-talk/07.svg\n<!-- \nV8实现了两个垃圾收集器:\n一种是经常收集年轻代，另一种是收集包括年轻代和年老代在内的整个堆。\n\n从老代到年轻代的引用是年轻代垃圾收集的根源。记录这些引用是为了在对象移动时提供有效的根标识和引用更新。\n\n由于年轻一代比较小（在V8中高达16MiB, 2017年的数据），它很快就被对象填满，需要频繁的收集。在M62之前，V8使用的是Cheney半空间复制垃圾收集器（见下图），它将幼代分成两半。在JavaScript执行过程中，只有一半的幼代可以用来分配对象，而另一半则保持为空。在年轻的垃圾收集器中，活的对象从一半复制到另一半，在飞行中压缩内存。已经被复制过一次的活对象被认为是中间代的一部分，并被提升到旧代。\n\n\n\n### young generation\n\n\n\n### old generation\nScavenge算法对于快速回收、紧缩小片内存效果很好，但对于大片内存则消耗过大。\n为此，V8在old generation(年老分代)中主要采用了Mark-Sweep（标记清除）标记清除和Mark-Compact（标记整理）相结合的方式进行垃圾回收。\n\n\n### 多线程 parallel Scavenger\n\n\n\n### 暂时废弃\n但还有一个问题, 当一个堆很大而且有很多活跃对象时，Mark-Sweep（标记清除）和Mark-Compact（标记整理）算法会执行得很慢。\n垃圾回收所引发的数百毫秒的停顿并不少见, 这种情况显然很难接受。\n \n2012年年中，Google引入了两项改进来减少垃圾回收所引起的停顿，并且效果显著：Incremental marking (增量标记)和 lazy sweeping (惰性清理)。\n\nIncremental marking (增量标记) 允许堆的标记发生在几次5-10毫秒（移动设备）的小停顿中。\n增量标记在堆的大小达到一定的阈值时启用，启用之后每当一定量的内存分配后，脚本的执行就会停顿并进行一次增量标记。\n\n增量标记完成后，惰性清理就开始了。\n所有的对象已被处理，因此非死即活，堆上多少空间可以变为空闲已经成为定局。\n此时我们可以不急着释放那些空间，而将清理的过程延迟一下也并无大碍。\n因此无需一次清理所有的页，垃圾回收器会视需要逐一进行清理，直到所有的页都清理完毕。这时增量标记又蓄势待发了。 -->\n<h4 id=\"referencing-\"><a href=\"#referencing-\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Referencing :</h4>\n<p><a href=\"http://www.jayconrod.com/posts/55/a-tour-of-v8-garbage-collection\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">a tour of v8 garbage collection</a><br>\n<a href=\"https://v8.dev/blog/trash-talk\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">the Orinoco garbage collector</a><br>\n<a href=\"https://github.com/thlorenz/v8-perf/blob/master/gc.md\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">thlorenz/v8-perf</a></p>\n<!-- [end](/thanks watch/) -->","timeToRead":2,"frontmatter":{"title":"The Orinoco Garbage Collector","date":"February 07, 2021","spoiler":"V8的垃圾回收器--Orinoco”"},"fields":{"slug":"/garbage-collection-in-V8/","langKey":"en"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/garbage-collection-in-V8/","previous":{"fields":{"slug":"/implementing-data-structures-using-javascript/","langKey":"en","directoryName":"implementing-data-structures-using-javascript","maybeAbsoluteLinks":[]},"frontmatter":{"title":"Implementing Data Structures Using JavaScript"}},"next":null,"translations":[],"translatedLinks":[]}}