{"data":{"site":{"siteMetadata":{"title":"Kaier33","author":"KaierChou"}},"markdownRemark":{"id":"a3b7b68a-ebb7-562a-bd9e-87e53c4f4a68","html":"<p>许多现代语言引擎，如Chrome的V8 JavaScript引擎，都能动态地管理运行中的应用程序的内存，因此开发人员不需要自己担心。引擎会定期翻阅分配给应用程序的内存，确定哪些数据不再需要，并将其清除以腾出空间，这个过程被称为垃圾收集。  </p>\n<p>任何垃圾收集器(GC)都有一些基本的任务, 它必须定期进行。</p>\n<ol>\n<li>识别objects的状态(live/dead)</li>\n<li>回收/再利用dead object所占用的内存</li>\n<li>优化整理内存</li>\n</ol>\n<p>这些任务可以按顺序执行，也可以任意交错执行。一种直接的方法是暂停JavaScript执行，并在主线程上依次执行这些任务。但这可能会导致主线程卡顿和延迟问题，以及降低程序吞吐量。</p>\n<h2 id=\"generational-garbage-collection\"><a href=\"#generational-garbage-collection\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Generational garbage collection</h2>\n<p>V8实现了两个垃圾收集器:\n一种是经常收集年轻代，另一种是收集包括年轻代和年老代在内的整个堆。</p>\n<p>从老代到年轻代的引用是年轻代垃圾收集的根源。记录这些引用是为了在对象移动时提供有效的根标识和引用更新。</p>\n<p>由于年轻一代比较小（在V8中高达16MiB, 2017年的数据），它很快就被对象填满，需要频繁的收集。在M62之前，V8使用的是Cheney半空间复制垃圾收集器（见下图），它将幼代分成两半。在JavaScript执行过程中，只有一半的幼代可以用来分配对象，而另一半则保持为空。在年轻的垃圾收集器中，活的对象从一半复制到另一半，在飞行中压缩内存。已经被复制过一次的活对象被认为是中间代的一部分，并被提升到旧代。</p>\n<div align=\"center\">\n  <img src=\"https://i.ibb.co/gW87MnK/gc-01.png\">\n</div>\n<h3 id=\"young-generation\"><a href=\"#young-generation\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>young generation</h3>\n<h3 id=\"old-generation\"><a href=\"#old-generation\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>old generation</h3>\n<p>Scavenge算法对于快速回收、紧缩小片内存效果很好，但对于大片内存则消耗过大。\n为此，V8在old generation(年老分代)中主要采用了Mark-Sweep（标记清除）标记清除和Mark-Compact（标记整理）相结合的方式进行垃圾回收。</p>\n<h3 id=\"多线程-parallel-scavenger\"><a href=\"#%E5%A4%9A%E7%BA%BF%E7%A8%8B-parallel-scavenger\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>多线程 parallel Scavenger</h3>\n<h3 id=\"暂时废弃\"><a href=\"#%E6%9A%82%E6%97%B6%E5%BA%9F%E5%BC%83\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>暂时废弃</h3>\n<p>但还有一个问题, 当一个堆很大而且有很多活跃对象时，Mark-Sweep（标记清除）和Mark-Compact（标记整理）算法会执行得很慢。\n垃圾回收所引发的数百毫秒的停顿并不少见, 这种情况显然很难接受。</p>\n<p>2012年年中，Google引入了两项改进来减少垃圾回收所引起的停顿，并且效果显著：Incremental marking (增量标记)和 lazy sweeping (惰性清理)。</p>\n<p>Incremental marking (增量标记) 允许堆的标记发生在几次5-10毫秒（移动设备）的小停顿中。\n增量标记在堆的大小达到一定的阈值时启用，启用之后每当一定量的内存分配后，脚本的执行就会停顿并进行一次增量标记。</p>\n<p>增量标记完成后，惰性清理就开始了。\n所有的对象已被处理，因此非死即活，堆上多少空间可以变为空闲已经成为定局。\n此时我们可以不急着释放那些空间，而将清理的过程延迟一下也并无大碍。\n因此无需一次清理所有的页，垃圾回收器会视需要逐一进行清理，直到所有的页都清理完毕。这时增量标记又蓄势待发了。</p>\n<h4 id=\"referencing-\"><a href=\"#referencing-\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Referencing :</h4>\n<p><a href=\"http://www.jayconrod.com/posts/55/a-tour-of-v8-garbage-collection\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">a tour of v8 garbage collection</a></p>\n<!-- [end](/thanks watch/) -->","timeToRead":1,"frontmatter":{"title":"Garbage Collection In V8","date":"February 07, 2021","spoiler":"浅谈V8中的“垃圾回收机制”"},"fields":{"slug":"/garbage-collection-in-V8/","langKey":"en"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/garbage-collection-in-V8/","previous":{"fields":{"slug":"/implementing-data-structures-using-javascript/","langKey":"en","directoryName":"implementing-data-structures-using-javascript","maybeAbsoluteLinks":[]},"frontmatter":{"title":"Implementing Data Structures Using JavaScript"}},"next":null,"translations":[],"translatedLinks":[]}}